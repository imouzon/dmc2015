print(a)
assign("a", 2, envir = parent.frame())
print(a)
a <- 3
print(a)
}
print(a)
g()
print(a)
}
f()
a <- 2
f <- function(x){
x + a
}
g <- function(x){
f(x) + 1
}
g(2)
a <- 2
f <- function(x){
x + a
}
g <- function(x){
a <- 3
f(x) + 1
}
g(2)
tourInitial <- matrix(c(60,180,80,140,
20,100,200,140,
40,100,180,60,
120,180,20,100,
200,20,60,160,
200,200,180,180,
160,160,160,140,
120,120,100,80,
80,60,40,40,
40,20,20,20),20,2)
n.city <- dim(tourInitial)[1]
popInitial <- randomPopulation1(tourInitial,50)
pop <- popInitial
# set parameters
mutationRate <- 0.05
iter <- 300
disALL2 <- rep(0, iter)
set.seed(2015)
ptm <- proc.time()
# evolve the population and plot
for(i in 1:iter){
disPop <- distanceOfPopulation1(pop)
print(min(disPop))
disALL2[i] <- min(disPop)
best.tour <- which(disPop==min(disPop))[1]
bestTour <- pop[,(2*best.tour-1):(2*best.tour)]
flush.console()
plot(bestTour[,1],bestTour[,2],type="o",
xlim=c(0,200),ylim=c(0,200),xlab="x coordinate",ylab="y coordinate")
segments(bestTour[1,1],bestTour[1,2],bestTour[n.city,1],bestTour[n.city,2])
pop <- evolvePopulation22(pop,mutationRate)
if(i%%50==0) print(i)
}
proc.time() - ptm
#############################################################
######################### Functions #########################
#############################################################
# calculate the distance of a single tour
# tourMatrix is a n time 2 matrix, each row is a city's coordinate
distanceOfTour1 <- function(tourMatrix){
temp <- 0
n <- dim(tourMatrix)[1]
for(i in 1:(n-1)){
temp <- temp+sqrt(sum((tourMatrix[i,]-tourMatrix[i+1,])^2))
}
temp <- temp+sqrt(sum((tourMatrix[1,]-tourMatrix[n,])^2))
return(temp)
}
# Check whether a city is contained in a Tour, return a boolean variable
containCity1 <- function(tour,city){
n <- dim(tour)[1]
temp <- FALSE
for(i in 1:n){
if(city[1]==tour[i,1] & city[2]==tour[i,2]){
temp <- TRUE
}
}
return(temp)
}
# generate a random population with size number tours
randomPopulation1 <- function(tour,size){
n <- dim(tour)[1]
temp <- matrix(0,n,2*size)
for(i in 1:size){
temp1 <- sample(1:n)
temp[,(2*i-1):(2*i)] <- tour[temp1,]
}
return(temp)
}
# calculate the distance of each tour in the population
# population matrix is the column bind of tour matrix
distanceOfPopulation1 <- function(pop){
n.city <- dim(pop)[1]
n.tour <- dim(pop)[2]/2
dis <- rep(0,n.tour)
for(i in 1:n.tour){
dis[i] <- distanceOfTour1(pop[,(2*i-1):(2*i)])
}
return(dis)
}
# crossover of two tours
crossoverTour12 <- function(tourParent1,tourParent2){
n <- dim(tourParent1)[1]
# Create new children tours and initialize as parents
child1 <- child2 <- matrix(-9999,n,2)
# Get start and end sub tour positions for parent1's tour
pos <- sample(1:n,size=2)
for(i in 1:n){
# If start position is smaller than end position
if (pos[1] < pos[2] & i > pos[1] & i < pos[2]) {
child1[i,] <- tourParent1[i,]
child2[i,] <- tourParent2[i,]
}
# If start position is larger
if(pos[1] > pos[2]){
if(!(i < pos[1] & i > pos[2])){
child1[i,] <- tourParent1[i,]
child2[i,] <- tourParent2[i,]
}
}
}
# Loop through parent2's city tour
for(i in 1:n){
# If child doesn't have the city, add it
if (!containCity1(child1,tourParent2[i,])){
# Loop to find a spare position in child
for(j in 1:n){
if(child1[j,1]==-9999 & child1[j,2]==-9999){
child1[j,] <- tourParent2[i,]
break
}
}
}
if (!containCity1(child2,tourParent1[i,])){
# Loop to find a spare position in child
for(j in 1:n){
if(child2[j,1]==-9999 & child2[j,2]==-9999){
child2[j,] <- tourParent1[i,]
break
}
}
}
}
return(cbind(child1, child2))
}
# mutate a Tour, mutationRate as a parameter
# each gene has a small probability (mutationRate) to change to a different gene value
mutateTour1 <- function(tour,mutationRate){
n <- dim(tour)[1]
tour1 <- tour
for(i in 1:n){
if(runif(1)<mutationRate){
# get a second random position in the tour
j <- sample(c(1:n)[-i],size=1)
tourTemp <- tour1[j,]
tour1[j,] <- tour1[i,]
tour1[i,] <- tourTemp
}
}
return(tour1)
}
# evolves a population over one generation, elitism is a boolean variable
# indicate whether elitist step is used or not
evolvePopulation22 <- function(pop,mutationRate){
n.city <- dim(pop)[1]
n.tour <- dim(pop)[2]/2
childPop <- pop
disPop <- disChild <- distanceOfPopulation1(pop)
# crossover population
# loop over the new population's size and create individuals from
# current population
for(i in 1:(n.tour/2)){
# select parents
temp <- sample(1:n.tour,size=2,prob=1/disPop)
parent1 <- pop[,(2*temp[1]-1):(2*temp[1])]
parent2 <- pop[,(2*temp[2]-1):(2*temp[2])]
child <- crossoverTour12(parent1,parent2)
disChild1 <- distanceOfTour1(child[, 1:2])
disChild2 <- distanceOfTour1(child[, 3:4])
disChild[(2*i-1):(2*i)] <- c(disChild1, disChild2)
childPop[, (4*i-3):(4*i)] <- child
}
disall <- c(disPop, disChild)
Popall <- cbind(pop, childPop)
newID <- order(disall)[1:n.tour]
newdis <- disall[newID]
newPop <- Popall[, as.numeric(t(cbind(newID*2-1, newID*2)))]
# mutate the new population a bit to add some new genetic material
for(i in 2:n.tour){
newPop[,(2*i-1):(2*i)] <- mutateTour1(newPop[,(2*i-1):(2*i)],mutationRate)
}
return(newPop)
}
#############################################################
########################## Example ##########################
#############################################################
tourInitial <- matrix(c(60,180,80,140,
20,100,200,140,
40,100,180,60,
120,180,20,100,
200,20,60,160,
200,200,180,180,
160,160,160,140,
120,120,100,80,
80,60,40,40,
40,20,20,20),20,2)
n.city <- dim(tourInitial)[1]
popInitial <- randomPopulation1(tourInitial,50)
pop <- popInitial
# set parameters
mutationRate <- 0.05
iter <- 300
disALL2 <- rep(0, iter)
set.seed(2015)
ptm <- proc.time()
# evolve the population and plot
for(i in 1:iter){
disPop <- distanceOfPopulation1(pop)
print(min(disPop))
disALL2[i] <- min(disPop)
best.tour <- which(disPop==min(disPop))[1]
bestTour <- pop[,(2*best.tour-1):(2*best.tour)]
flush.console()
plot(bestTour[,1],bestTour[,2],type="o",
xlim=c(0,200),ylim=c(0,200),xlab="x coordinate",ylab="y coordinate")
segments(bestTour[1,1],bestTour[1,2],bestTour[n.city,1],bestTour[n.city,2])
pop <- evolvePopulation22(pop,mutationRate)
if(i%%50==0) print(i)
}
proc.time() - ptm
plot(1:iter, disALL2, type = "l")
lines(1:iter, disALL1, type = "l", col = "red")
# calculate the distance of a single tour
# tourMatrix is a n time 2 matrix, each row is a city's coordinate
distanceOfTour1 <- function(tourMatrix){
temp <- 0
n <- dim(tourMatrix)[1]
for(i in 1:(n-1)){
temp <- temp+sqrt(sum((tourMatrix[i,]-tourMatrix[i+1,])^2))
}
temp <- temp+sqrt(sum((tourMatrix[1,]-tourMatrix[n,])^2))
return(temp)
}
# Check whether a city is contained in a Tour, return a boolean variable
containCity1 <- function(tour,city){
n <- dim(tour)[1]
temp <- FALSE
for(i in 1:n){
if(city[1]==tour[i,1] & city[2]==tour[i,2]){
temp <- TRUE
}
}
return(temp)
}
# generate a random population with size number tours
randomPopulation1 <- function(tour,size){
n <- dim(tour)[1]
temp <- matrix(0,n,2*size)
for(i in 1:size){
temp1 <- sample(1:n)
temp[,(2*i-1):(2*i)] <- tour[temp1,]
}
return(temp)
}
# calculate the distance of each tour in the population
# population matrix is the column bind of tour matrix
distanceOfPopulation1 <- function(pop){
n.city <- dim(pop)[1]
n.tour <- dim(pop)[2]/2
dis <- rep(0,n.tour)
for(i in 1:n.tour){
dis[i] <- distanceOfTour1(pop[,(2*i-1):(2*i)])
}
return(dis)
}
# crossover of two tours
crossoverTour1 <- function(tourParent1,tourParent2){
n <- dim(tourParent1)[1]
# Create new child tour and initilize it as parent 1
child <- matrix(-9999,n,2)
# Get start and end sub tour positions for parent1's tour
pos <- sample(1:n,size=2)
# Get start and end sub tour positions for parent1's tour
for(i in 1:n){
# If start position is smaller than end position
if (pos[1] < pos[2] & i > pos[1] & i < pos[2]) {
child[i,] <- tourParent1[i,]
}
# If start position is larger
if(pos[1] > pos[2]){
if(!(i < pos[1] & i > pos[2])){
child[i,] <- tourParent1[i,]
}
}
}
# Loop through parent2's city tour
for(i in 1:n){
# If child doesn't have the city, add it
if (!containCity1(child,tourParent2[i,])){
# Loop to find a spare position in child
for(j in 1:n){
if(child[j,1]==-9999 & child[j,2]==-9999){
child[j,] <- tourParent2[i,]
break
}
}
}
}
return(child)
}
# mutate a Tour, mutationRate as a parameter
mutateTour1 <- function(tour,mutationRate){
n <- dim(tour)[1]
tour1 <- tour
for(i in 1:n){
if(runif(1)<mutationRate){
# get a second random position in the tour
j <- sample(c(1:n)[-i],size=1)
tourTemp <- tour1[j,]
tour1[j,] <- tour1[i,]
tour1[i,] <- tourTemp
}
}
return(tour1)
}
# # evolves a population over one generation, elitism is a boolean variable
# indicate whether elitist step is used or not
evolvePopulation1 <- function(pop,elitism,mutationRate){
n.city <- dim(pop)[1]
n.tour <- dim(pop)[2]/2
newPop <- matrix(0,n.city,n.tour*2)
disPop <- distanceOfPopulation1(pop)
disRank <- length(disPop)-rank(disPop)+1
best.tour <- which(disPop==min(disPop))[1]
elitismOffset <- 1
if(elitism){
newPop[,1:2] <- pop[,(2*best.tour-1):(2*best.tour)]
elitismOffset <- 2
}
# crossover population
# loop over the new population's size and create individuals from
# current population
for(i in elitismOffset:n.tour){
# select parents
temp <- sample(1:n.tour,size=2,prob=disRank)
parent1 <- pop[,(2*temp[1]-1):(2*temp[1])]
parent2 <- pop[,(2*temp[2]-1):(2*temp[2])]
child <- crossoverTour1(parent1,parent2)
newPop[,(2*i-1):(2*i)] <- child
}
# mutate the new population a bit to add some new genetic material
for(i in elitismOffset:n.tour){
newPop[,(2*i-1):(2*i)] <- mutateTour1(newPop[,(2*i-1):(2*i)],mutationRate)
}
return(newPop)
}
evolvePopulation2 <- function(pop,elitism,mutationRate){
n.city <- dim(pop)[1]
n.tour <- dim(pop)[2]/2
newPop <- pop
disPop <- distanceOfPopulation1(pop)
disRank <- rank(disPop,ties.method="random")
best.tour <- which(disPop==min(disPop))[1]
elitismOffset <- 1
if(elitism){
newPop[,1:2] <- pop[,(2*best.tour-1):(2*best.tour)]
elitismOffset <- 2
}
# crossover population
# loop over the new population's size and create individuals from
# current population
replaceTime <- 0
for(i in elitismOffset:n.tour){
# select parents
temp <- sample(1:n.tour,size=2,prob=1/disPop)
#    temp1 <- which(rank(disPop[temp],ties.method="random")==1)
#    temp2 <- which(rank(disPop[temp],ties.method="random")==2)
#    parent1 <- pop[,(2*temp1-1):(2*temp1)]
#    parent2 <- pop[,(2*temp2-1):(2*temp2)]
parent1 <- pop[,(2*temp[1]-1):(2*temp[1])]
parent2 <- pop[,(2*temp[2]-1):(2*temp[2])]
child <- crossoverTour1(parent1,parent2)
#    for(j in 1:100){
#      childTemp <- child
#      mutateTour1(childTemp,mutationRate)
#      if(distanceOfTour1(childTemp)<distanceOfTour1(child)){
#        child <- childTemp
#      }
#    }
disChild <- distanceOfTour1(child)
posTemp <- which(disRank==length(disPop)-replaceTime)[1]
if(disChild < disPop[posTemp]){
newPop[,(2*posTemp-1):(2*posTemp)] <- child
replaceTime <- replaceTime+1
}
}
#print(posTemp)
#  print(replaceTime)
# mutate the new population a bit to add some new genetic material
for(i in elitismOffset:n.tour){
newPop[,(2*i-1):(2*i)] <- mutateTour1(newPop[,(2*i-1):(2*i)],mutationRate)
}
return(newPop)
}
############################################################
###########   Example
############################################################
pop <- popInitial
# set parameters
elitism <- TRUE
mutationRate <- 0.05
iter <- 300
disALL1 <- rep(0, iter)
set.seed(2015)
ptm <- proc.time()
# evolve the population and plot
for(i in 1:iter){
disPop <- distanceOfPopulation1(pop)
print(min(disPop))
disALL1[i] <- min(disPop)
best.tour <- which(disPop==min(disPop))[1]
bestTour <- pop[,(2*best.tour-1):(2*best.tour)]
flush.console()
plot(bestTour[,1],bestTour[,2],type="o",
xlim=c(0,200),ylim=c(0,200),xlab="x coordinate",ylab="y coordinate")
segments(bestTour[1,1],bestTour[1,2],bestTour[n.city,1],bestTour[n.city,2])
pop <- evolvePopulation2(pop,elitism,mutationRate)
if(i%%50==0) print(i)
}
proc.time() - ptm
plot(1:iter, disALL1, type = "l")
plot(1:iter, disALL2, type = "l")
lines(1:iter, disALL1, type = "l", col = "red")
train <- read.table("//Users/Ran/Downloads/DMC 2015/DMC_2015_orders_train.txt", sep = "|")
head(train)
train <- read.table("//Users/Ran/Downloads/DMC 2015/DMC_2015_orders_train.txt", head = T, sep = "|")
head(train)
class <- read.table("//Users/Ran/Downloads/DMC 2015/DMC_2015_orders_class.txt", head = T, sep = "|")
head(class)
setwd("//Users/Ran/Downloads/DMC 2015")
setwd("//Users/Ran/Documents/ISU/dmc2015/")
setwd("//Users/Ran/Documents/ISU/dmc2015/")
train <- read.table("data/raw_data/DMC_2015_orders_train.txt", head = T, sep = "|")
class <- read.table("data/raw_data/DMC_2015_orders_class.txt", head = T, sep = "|")
names(train)
head(train)
train$couponID1
nlevels(train$couponID1)
summary(train)
nlevels(train$orderTime)
table(train$orderTime)
table(train$orderTime)[1:4]
table(train$orderTime) == 2
train$orderTime[table(train$orderTime)] == 2
train$orderTime[table(train$orderTime) == 2 ]
attach(train)
nlevels(orderTime)
orderTime[table(orderTime) == 2]
train[table(orderTime) == 2,]
orderTime[table(orderTime) == 2]
table(orderTime) == 2
nlevels(orderTime)
summary(train)
orderTime[table(orderTime) == 2]
train[table(orderTime) == 2,]
nlevels(orderTime)
summary(train)
orderTime[table(orderTime) == 2]
train[which(table(orderTime) == 2),]
orderTime[table(orderTime) == 2]
train[which(orderTime %in% orderTime[table(orderTime) == 2]),]
train[orderTime %in% orderTime[table(orderTime) == 2],]
train[orderTime == "2015-02-23 21:52:30"]
train[orderTime == "2015-02-23 21:52:30", ]
summary(train)
train[orderTime == "2015-02-23 22:14:46", ]
orderTime[table(orderTime) == 2]
as.vector(orderTime[table(orderTime) == 2])
train[orderTime %in% as.vector(orderTime[table(orderTime) == 2]),]
orderTime[table(orderTime) == 2]
as.numeric(table(orderTime))
table(orderTime)
as.vector(table(orderTime) == 2)
as.vector((table(orderTime) == 2) == 1)
table(orderTime)[table(orderTime) == 2]
as.vector(table(orderTime)[table(orderTime) == 2])
as.numeric(table(orderTime)[table(orderTime) == 2])
table(orderTime)[table(orderTime) == 2]
orderTime %in% table(orderTime)[table(orderTime) == 2]
orderTime[orderTime %in% table(orderTime)[table(orderTime) == 2]]
orderTime %in% table(orderTime)[table(orderTime) == 2]
sum(orderTime %in% table(orderTime)[table(orderTime) == 2])
table(orderTime)[table(orderTime) == 2]
table(orderTime)[table(orderTime) == 2]->a
table(orderTime) == 2
names(table(orderTime) == 2)
names(table(orderTime)[table(orderTime) == 2])
train[orderTime %in% names(table(orderTime)[table(orderTime) == 2]),]
summary(train)
library("SimSeq", lib.loc="/usr/local/Cellar/r/3.1.2_1/R.framework/Versions/3.1/Resources/library")
SortData
SimSeq
SimSeq
SimData
